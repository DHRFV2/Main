
    local Byte         = string.byte;
    local Char         = string.char;
    local Sub          = string.sub;
    local Concat       = table.concat;
    local Insert       = table.insert;
    local LDExp        = math.ldexp;
    local GetFEnv      = getfenv or function() return _ENV end;
    local Setmetatable = setmetatable;
    local Select       = select;

    local Unpack = unpack or table.unpack;
    local ToNumber = tonumber;local function decompress(b)local c,d,e="ScriptGuard","ScriptGuard",{}local f=256;local g={}for h=0,f-1 do g[h]=Char(h)end;local i=1;local function k()local l=ToNumber(Sub(b, i,i),36)i=i+1;local m=ToNumber(Sub(b, i,i+l-1),36)i=i+l;return m end;c=Char(k())e[1]=c;while i<#b do local n=k()if g[n]then d=g[n]else d=c..Sub(c, 1,1)end;g[f]=c..Sub(d, 1,1)e[#e+1],c,f=d,d,f+1 end;return table.concat(e)end;local ByteString=decompress('23I22X27522W22V27522X11161612141C1T1827F1T27B1D22W2312791E27I1C22W23227925X22722Q1E1D23J1I22W22Q279171C1U1A1A15161Q1S1R27S23D279101D1C171T101F1G1C1H1C1A1S1T161R22W22R27927F1Q1Q181E1C1B161H28Z27928B181D1Q1T1R10171E27T27928F1O1S1C29G22W22Y27921O1R1522W21R27926A22S23J1G1Q1W21X25L24M23N23C25222K2621D25A22D22L22T21525U22721222T21E1525O1221C26721623V26B22M24N26F26I28T1N25K1L26C26D1J24W25C23F22S1123R1X21621121224N21P24V1K24124F21O1C2721327221Y1P22Y2AK24025H23U26T22F23A25N22H26623A25S26Z21021724U22W23327921027G27L29T27925P22D22N27N279217161D1G22W27922X2CE27929G29I29K2CK27528D1B2CP2751A11181R22Z2CW2CW2DD2CW23T162152DG2CW24922E22W21D27923U1G1B22O22X1Q22Y26E25W26A1F24821N24Z23D25Y1W21R1G22I25321P21X1A22K23524P23021W26P22126C23Y23526B24V25422222K21126F22G23P23W23H24F24Y1U1223624O22122721W21U25W1I25E23926W26P1J23124323023V21423I1V1M21T27324Q26924321Q1E26C1K25B1V25A25X22022M25R21Y2472DL27921R2DK2DE27521522I2CV22X2DL2GI2GC2GH2792GJ2752GN2GL2GO2GM2GS2GR2GU2GQ2GW2GP2GY2GT2GX2H02GZ2GV2H32H12H42H22H82H72HA2GK2HB2H52HE2H92GW2DF2HG2HF2HD2H02HI2HB2HN2H62HQ2HK2HH2HC2GK2H52HU2HV27923F2HZ2HG2I027523H2792I527523J2792I92752352792ID2IC2IE2GK2IF22X2IJ2IL2IH2IG2IO2IK2IN2IQ2IP2IM2IT2IR2IU2IS2IY2IX2J02IW2J22IV2J42IZ2J32J62J52HC2J12J52IJ2CW2JB2J82IY2JE2J72JF2JK2IR2JI2J92JJ2JP2JC2JM2HX2DE2JF2JT2JU2JS2JR2JZ2JG2JL2K02K22K12JQ2K52K32K62K42IX2JA2K92JY2K72KF2KA2KD2K82IP2JN2KG2KI2JH2JW2K62KP2KN2IX29U2752392792832792D928T121A1815151C28Y27O27527Q27F29B27521A27G21M2L71V101A28G27926722R2321I1W2381Q24324G24X22Y26I2252621Q24Z22W22T27926623J23I131122N1423R25223Y22Y27022W22U27925D239236121623F1O23M24123W23226Y22F25Y1T2LD22X25F23I23F1L1T2MC23M24X23Q22W22P2791W1729G18172LL2D322X2861U22W22S27925K23D22T141823C1623N24124422Y26U22722W2302792181V28L2N02ND27526123C23I1K1D2391T23S2NC27928W2D029J29L2842752N32N51T22D1823W24X23L23F2NP2LN2LP2LR2LT2LV25223A26G22M2D722X218171S142P327521O1Q2L72NF1P28V21P1G1P27S2OC22X1Y1C2DT162DB27M2CW2CY2D429H2OQ2NL2D52PD2D92DB2G82HP2752DI2GB2DE2DN2DP2DR2DT2DV2DX2DZ2E12E32E52E72E92EB2ED2EF2EH2EJ2EL2EN2EP2ER2ET2EV2EX2EZ2F12F32F52F72F92FB2FD2FF2FH2FJ2FL2FN2FP2FR2FT2FV2FX2FZ2G12G32G52G72GC2GA2QD2GD21W2KU2KU22X2S02S22792L922X2S52S52CW2S72S42SB2752SA2SD2SC2S62SG2SE2SH2SF2SL2SK2SN2SJ2SP2SI2SR2SM2SQ2ST2SS2SO2SW2SU2HU2SZ2T12SY2T32SV2T52SX2T62T22T82T42T72TC2S82KR2TD2TF2S92SG2TI2752O62GC2TM22X2TO2TQ2792TR2TL2TS2TV2TU2TX2TP2TW2TZ2TY2TT2U12U42U32U62U02U72U22U82UB2UA2UD2U52U02HC2U92UF2TY2CW2UI2UI2UL2UC2UJ2UQ2UM2UP2TO2UO2UE2UV2UR2UT2TH2UZ2V02UQ2CF2752V422X2V627U2GC2V922X2VB2VD2792VE2752VG2VC2VF2VK2VH2VL2VJ2VM2VP2VO2VR2VI2VT2VN2VU2VQ2VW2VS2VV2W02VX2W12HU2VY2W52VN2CW2W62VA2W32W92VZ2W22WE2VR2W82W32WH2WF2WC2TH2VY2WM2GK2VB2PV2WR2792DV2GC2WU22X2WW2WY2WT2X02752WZ2X22X12WX2X52X32X62X42XA2X92XC2X82XE2X72XG2XB2XF2XI2XH2XD2XL2WW2HC2XJ2XM2XK2XB2CW2XQ2XV2XN2XX2XS2XR2XC2XU2XL2Y22XZ2XW2V22XQ2TH2XO2X52902752YC22X2YE2CW2YE2YI2792YJ2YD2YK2YN2YM2YP2YF2YO2YR2YQ2YL2YT2YW2YV2YY2YS2YZ2YU2Z02Z32Z22Z52YX2Z42HU2Z12Z72YQ2YH2Z82ZA2ZF2ZE2ZH2ZC2ZI2ZB2YW2ZD2Z62ZG2V22ZA2TH2ZA2NQ2752ZU2DE2ZW2ZW2CW2ZY27931012ZV310231053104310722X310331093106310B3108310A310F310C310G310E310H310K310J310M310D310O310I310P2JT310Q310Q3100310C310V310N310T310L310R310Y310W31102ZZ31142GK310Z31122V2310U2TF311822X278275311F311E279311H2CW311H311M311J311O311G311P311I311Q311T311S311V311N311U311X311W311R311Z312231213124311Y312531203126312931282HU3123312A312D312B311Z311L3127312F312K312J312M312E312N312B2TH312F312R2GK312H312P312L312O312Y312G312W3131312Z312X31303133312P2HC3134312V312A312I3136313D3135313F31393132313G2V2313F312T313E311H23C279313P275313R22X313T313T2I32CX2GK2GG310O2Q32CW2342KX2CW2RY27523F2372GL314022X1S314B2GL2332112GL22622Y3140231313T314K2CV31492GL2DL2212ND2DD2DD29U2I32O62TE2VJ2TO2DG27U2VB2VK31562VM27U314Q2X423E2I12YR2I722X2212YM29023G22X2I3284315G315I22X2842842IB2752M52CW2I32NQ2743148311Q2IJ2I32MK31442SL2NQ236313Y2SH313P2OS2SF2I028H27921B313U314S275315L2M528H313R316M316J28H2L92NQ315L314Q1Y310B314A3148316X27831662D422X2MK2VB23F316X28H31732311J311I21J313Y221229315M316J31442212A02I02I03169315Q317O22X317322X315D2YA22X2I52PV279315L2YG2I82WG275274313T2IH3188316L2IQ2G8316Q315L2IA2ZM318631412IG313X2793144318L318431442G82I92M5315U2IQ318F314322X315U2DG2ID2JD2IG31922IQ2ID315B22X314A31732I331693160311E1022X2741W313Y2ID314N2NE313Y22V319F319H313Y3144319L275319I2CV2212MK2KW2ID2KW319X22X238317T22X2KW23321C31A622X214313Y31A4319T31AB316A22A22X31693169316Z2KW23B2IQ31A122D22X31AO31AO2KW27923A31A531A4315Q31AX31AX31A1275314A314A31AV275314431AX2JX31AO2SM22X317I2CV2332782ID314I2CV319S313T31BK2SF2ID3173319O319G22X21Q319J2S6313T31BV319W319Y31AP319E31BT21N313Y2KW31AF31C52GG31AI31AK31982KV31A331C222129031A431A431A122431CD31B631BP31CF2SD31BN316A27O2I531692SB315L31B722X1X311V31CR27921E316A1N317Y22X2M52I7182X6315D2I52L9278315I2GG27O27O2XO27O2O62YG31D12UU31BX2791B316A31C52DD27O2DD31A82791F313Y31DX313T31E22CV31AF24E22W316W2S12U422X22J2TZ2S02DG2O631DR2TZ31EK31EJ313Y2I327U315D316122X2ND315P2752ND2ND315L2I32DV31EV2X62DV318U3183315N31BT31ES2M531633104317B2752841I31CT31752Y127O28H311K316I2MK314W318B2902782MK22X318231FI2782L9284314E31EB284316Z315M316X2M5317U1Q310B2TO3178311I317B317D2M524R317G317I28H3165315H2A028H28H317Q27531GN31A5313Q3185317J2V6279315D31802I431ED318B31FT2CW2I931H331GX318Y2HH315D29031ER31H031GZ31FU315R2GC2I9316G2CW27431HJ2I631BT2G82I5290315G31H831HC279274315G2DG2I9318U318431I031H82I9319731BQ315E3144319D22V2O627426Q313Y2I931AF31ID31E7313T25E319N319P22X31IK2CV27431AF31IO315H2MK314A2I931A12MK319C31AA23322E31CD25N313Y316931AF31J431II27925M31AH31A531442IF2KW2KW2I9314A22131AR31JG31AA27931A427431GP31CF31CK315H319331JN318I31A42DE31IW2TJ26P313Y31BH31H825J313Y31IQ313T31K631DJ31H831I931IB22X26031IE31DS27531KG31J927525U317G31IU31H82KW31IA31BT264313Y314A31AF31KU31KL22X26731JC314431JE31CE316931JI315H29031CC31CL319531JN27O2I931CW31KI22X31KA316E31GS2SF315D31G331D031D231LH25Y31D6317J2902I331DC27U313P2I02L92M526H31FH2DD315627O29U318031D12S031D327524V31K331J22CV24I31E331LH31MI2GG2252HT31D9316K31MC22X31E931EB29U31GW31EF2O631EH2TU31EM31H131EL31EO2VM31HC2I331EU279315Q31EX31HF31F031D8275315Q2DV31F42ZN315E284319D2I331FA315E2NQ31FD31HG23T31FH2MK31DM22X31FL2CW31FN31MQ31FV31FS31FQ31FW2SK28424Z31EO316X31G22HZ31G531LL2DW31G931OC31GC2S431GE22X22631EA315H31GI31FI317L31GM31NX31AJ31JU31OT317A2CW313P315831GV2GC31GY2GC2I531EK315L31H6318431P8317V31H82G831HA31PB31HN31HE315L316D318G31HM318I31PL31D827431HP315F31H431PF31HK31NE2GQ31HZ31HH31H831JZ31H831I531LL2I331I8311J31IM23D31ON31IF313T31Q82CV31KS31PP31ON31K82GM31ON31AF31QC31IT31CD31K031A231IZ31A731J2314A23231ON31J6313T31QU31KZ22P31ON22X31AI31L32IS31JM31L731JK31AA31JM31JO31BT31JR31CJ31AA315Q319131JW31BT31JY31PS31B72S824431K32782I923E31QG31LH31RS31KB2I931KD31BT23J31Q931LH31S031KZ22131ON31A231IV31AA31QE319831ON31KW313T23731QJ313T23631R131R331A531JF31OU31R731L931OU31LB31RH31AV31LE31OU31MR31RV31LK317U27O31LN2CW31D1311K31LH22531R131D72I031LV27531LX316J31M0315V22X23W31M42WG31M731ET31T231EC2S9313T21U31ON31E02CV21Z31ON31E427931TU31KZ22G31R131MN2DD314C2M531FP31MR31MT31G431EC315631MX31TN2GQ31EN2DE31UF2UO2O6319731EQ315E31N831NF31EW31TL31EZ2X431F231NH31PZ2ZJ31F731NM31TF31FB310B31NR28421B31R127O31NV2TI31NY316H31FI31U631O231FI31HF2902MK31FX31FE22X21531ON31GB31OB317031MP31G731OG31VP317231OJ31MP26D31S631OP31GK317M31OW31OU315Q31GR317U31OZ2GC2I031GW27531P32DE31P52GC31P731PY31PA315D2I931PD2YR31HU317Z31WF31HG31Q031PN31HL31P431HO2CW31HQ31PV31HT2GC31HW2GT31PX31Q031I231PX31Q2319A31B831F831C32741S31S131AF31XD31QD31KE1131RT31AF31XJ31KZ31XG31QM31S831IX31OU27431A731A9314A2PI2CV31QW29131SJ31JD31R531AA31R731JL31R92CW31JP31W327531RE31B331LC31CZ27431RK318G31RM2CW1A31TR31RQ22X29A31IP31LH31YP2SF31RX311J31KE2822CV31QA27931YX31LH26K31S631KP31K031SA1M31SC31LH31Z831KZ26H31Y131R431SM31L631CD31CH31OU316931SR31C22SH31LF2S4313T31YS2SH2I031SZ31PB31LO31T32DE31AF26831T731LU317J22X31TC31LZ2SK2M51Y31V52GL31M631EC31M931UD31MR26X31TR31A92CV26Y31TV31LH320M31KZ31U8314R2DD2PV22111316K2DV2I327O31832V72SN2DG2CF31WA32123216321531N431TL31N631US31N92X42DV31UR31PR31UO2YR290318U31PJ32042M531UY310B31V031VU2SL2M525F320B28H2YG27O313P31H6316I28H31VC31HG2MK316G31PI31OT2MK31M122X25P31VM31OD31G331GB31NQ2CW31G82782V631GB31GK2SD317D2NQ24931VY316R31A531W1313P313P31JR322Y31OE2I031HE315D31P02I5317X315L321631HI31X031OT31WD31WV31HN315O2CW315L317X318S323C318A2IQ323N315L2ID318D31HG318W31BT31HS2IG318W2DG274319D31HV31XA3242274319731R431ES314A31RY27424J31XK313T324C31KZ24W31ON31BS274324H2CV319K313T324L31QM31QQ31QM319Z31J031A9316925431ON31C7313T324X31CA31CN31GS2KW31Y9317Q31AR31YC2CW31AO31A031OV31AT31RF31X9314431CZ2ID31BC31PU31RK2S82CD31BG21M31BT25131ON324N279325S31KZ250320B2742IJ324J22X23K324D279326431C031XS31S931KE23U31QV31LH326C31KZ23X31Y131B5325431AA31JQ31L831Y731LB31R431ST31BT31RM313T325Y31KB31T12SB31CV31TM31T431AF23O3202315D28431ER31DC2ND2I0315D316T22X25I320B31M82TI31DL31TM2TE31AF24D31R1316I31FP2DD22112316K2OS31U52GW320S2GW31E0275242320N31AF328131KZ1922Z31MU31MP27931UC31MZ31N331UG31N231EN31UK31PT31N731PV31NA31UQ320431F1321E31F331UV318H31UX315E31NO31ES322J2SL28423D32872SF31V72SB31V927531O0322531FR31VE31FV31VH31O62YF329131VN31CD31VP31G6322K31VS31U9321T2S631OK21D3291317H322A322W31OS31GO31OV31W531OY31GU31W931P231TL323E31P631VE31PS31WI31PC2CW31PE31WN32A3323I31WQ31PS31WS323D31WW323F31H031HR31PS31HU318I31HX31I131PY31X531Q1320431I631ES31Q5311G31KE22H329131YZ27532B131KZ2DK31XH31BT22I329131QH27532BA32B6329R31Z531RF31IY326S2V731XV31BE329131XZ275229329131R231Y231SM31JH31ZI31Y631RA31YB31RC31OV325931RG31ZN31JX31PY31YJ27921W3291233325Q2I921632BB31LH32CF31KZ21932BS31SU324A22X21A32B231LH32CP31KZ21K32BG31QN326A31BT1Y329131SD27932CZ31KZ21132BS31SK31L431AA31ZH31JJ31SP31ZL315H31CM31SS31YT31SV31LH32CK31KB31ZU2TI326X27531ZY31TO29V32BS31T82YR31LW2VJ3207322C23G32CL320C2TI327G27931MA31ZZ313T21H32CB31MG22X32862CV31TW27532ED2GH1R31MO327V2DL327X2ZZ1O320G2HI31FP320Z31LQ32122S5321432122DE321932EZ321231972ND321C2X631UT2X6321H32AM321J290321L2CW321N31NN31XA315Y2IY2I3329N322C1H32E1321Y2TI322131NZ31OT32252843227318B328Z31FI322C2DC31EB2M5322H316X328X3174322M31OH322P329O310B25X329R317I313P31OX322X316J3230317K315X32AD31H732362Y1318B323A32AI324231PN2I531PP32AJ323H318132GQ31H8315W31PU323N2ID323P318C32AE284323U31X12JX323Y318I324132HF323C3245320432473204324931Q631BT25Q32CG31AF32HQ31QD31IM32HT2IQ32HS32CV324R31A2324T31QR31OU26V3291324Z27932I531KZ26U32D632533166325532C131R83259279325B325F31AS32IM31YD326Q2JI325K3242325M2CW27032CB27827425F3291325U2OT32E1326032HO27426432HR313T32J73268324R326226132BO31LH32JE3252326J32IE326L31W329031JM326P31A5326R31XT31ZQ27932IZ326W329H2SF326Z32E531LQ31AF25S32DT31PB327631TB31TL327A2SK2NQ1K32E132E42SF327I32K0327K313T24P32CB31A92DD24Q329129U31AF32KO31KZ314P31U929U31H6328B2GT31UH2TV31N131UJ320431UL31ES31UN31OV31NB321H328O321J31UU31F52DE328T31F932FJ31FC2SC28424X32E132932SF329522X32972GQ31VD31FT329B311I31FY22X257329F31OA32JX31GB329J2CZ329L31GB32FL31OK238314L31OO329T31OR31W231JR329Y31GT31P032A12DE31WC32AJ32A531PA31H532A231WK32AA31WM32AJ31PH32AF31PK323C32GV32AK31D832FA318432AO323V31X2328R32AR31X4321A32AW32HK31XA31SA24132CQ31AF32NH31QZ32MC31SA24232J827932NO32NL326831XQ324Q32BK31E0316Z32MC32BP27532MC32BT31ZF31CE32BW31JJ32BY31RI325632C231CF31YD32DG32IS32C72TJ24C32IW31H822Q32MC32BC315R32O232CM32J5318Y32MC32B332OS32NT31KQ31XB313U32MC32D1313S32O232D731Y332DA326N31LA32DE31YE32DH31LG31AF32OL32DL31OE31T032JX31LP327131SE32O232DU31TA320532DX317J322C25032E131M532E332GN32E632DR27522032MC31J1313Y32KU32EF31OL32MC327X31HJ327R316K313P32QB32ES31TF31U62GD31MO2NQ31MB2TI314C2GR31512RW31422GO316D2PD26523523H29Y2Q32V62OP2D22S02Q92S52QB2DC2HC2QD2QG2RW2QJ2DQ2752DS2DU2DW2DY2E02E22E42E62E82EA2EC2EE2EG2EI2EK2EM2EO2EQ2ES2EU2EW2EY2F02F22F42F62F82FA2FC2FE2FG2FI2FK2FM2FO2FQ2FS2FU2FW2FY2G02G22G42G62RW2RV2GK2151931HN31WU31H032SU31PV315G32SX32SS32SW32SZ32SY32SV32T232T032T332T132T732T632T932T532TB32T432TD32T832TB2HC32TE32TA32TI32TC32TF32TK32TN32TM32TP32ST32TG32TQ32TL32SV2TH32TK32TW32SZ2CW32SR314831AO2CV32QN31EC31402DG29U32QL31EC32UA32U9321A2O632EM2V531UD315Q321927O31EP32UI315931ED31GZ31ND322N2YM317731VJ2PV2L9321G31FH2NQ320D27832H332LR310B32252ND2M52ZU315L2ND2NQ2M532UX31FI31EB31UU31VP290318031G82842S032M432AD317C2YR21F31GH311I2NQ2ND31W1278278290315Q32VY32GN2MK31EK316S2GC313P32162I032UA315D311531D832WD313P2I52G8313P2ND318832ML32MU317X2I531T431HF32WQ2I0315L2G83233320431H032H7313X2DG2I5323W31D832X332X2321A2I92PV2I32742V631BS2CF216313Y31DF313T32XF32HU321232XJ31HF31AF32XM31A22ID2I528431A23144322931E02ID31AI31BL31LH32XZ27531AI324031PZ2KW314A2I52ID31R8326J31PJ3169315L317L27531CC32XT32AR31PJ315L31LG31HN31G32S831EF31BG2782I5316I2CV315L31AF32YV32JY31HF32AZ3212319V31D831AF32Z431AF325Q326832XR31HG31KS2CF21031BW31AF32ZF31KZ21331JC32Y52IB2KW314432Y9326N31R432XT31CM31PX2OS31CU31LL32YY31FH28H324132202JH32DQ32JT27531BZ27531D728H2ND316G31DC2O632FW2L9290314A31KB2UK27O31BG31TM32QN31AF317F2GG32H32G83173314C311H2O52791P2D12N0314025T2N125J23923C1J1823H1F24K25724A22W2DL25Z21C314C2Q42DW2Q632R22CZ1S2D632R52DA32R72HY2DH2DJ32RB2DO32RD22X32RF2QN32RI2QQ32RL2QT32RO2QW32RR2QZ32RU2R232RX2R532S02R832S32RB32S62RE32S92RH32SC2RK32SF2RN32SI2RQ32SL2RT2DE32SO2GC2152242GG315U31I231UV3332318G3184333733343336333933383335333C333A333D333B333H333G333J333F333L333E333N333I333M2HU333K333O333S31Q0333T333Q333U333Y333Q31PS333O3341333P333W33452V0333U2TH3348333X334B3346333Z334D334C3344334H334E334I334G334J2HC334J333G33433333334M334L334T334F334V32N9334W334A2KR334Z2KP334R334U334K334Y3354334O3357335933563346334N335A333V334X3355335F3358335B335H335J335H334933402TF334S2753330314831A431U3315E31DY2GC2CF32EW32UH321832EY2CW321932F32U432UR328P31UU27U2I32902V6315Q32FC32GN32FF31TF2WW32FI2YE32FK32AF322C31I432LP2ZM3303322232FT32LT3226323D322931GJ320831OT32G2328931U92NQ31PJ322L3364322O336P322R22X21H32VT32GG31HG32GI313P2NQ315Q323131PJ32WW32MM31GU323731WP32GS32AH32N132GX323G31WY323J31PY32V3318I32H5316J2DE323Q2HH322932HB31WY323X2GT32Y52DE338E31PU32HJ31Q432AF2I3314A2WW31BS2DV21831K731LH338Q32B82DV31BF32HX313T338W31AF338T32NV27431DH31C12ID322M324V22X22C31C631LH339A32JI31CD32JK32OA32IH31CF311K32IK31YD325E31DH325G31D2325J323C32IT27922I31K3325Q27431D1324M31LH339Z31LH32Z42SH32J432Z22DV31BO32ON31BO31AF21O31KO326932VY319F2DV21L31J531LH33AJ339E319932O532IG32JN31S932P931R4311F27O32JS31MR33A432PH31LO32ZX32YN330531MR320K330932K531PF3278317J327B3104316931KB32KE2SH32KG32DP2SN31MR32SR31BG22B2SH31GG32U431LH33BQ31U931MY2CW31EF27U315332UO2DE31552WA315A328N33682YM336F315J2VJ31F733C831HG2843180338232FI336L311Q336N2752MK316D327C1U31FH316C2TI316F32FS313P3225316N3385316Q337H327C32EP31EB32VC31OH278337831FI31773179337C311I25Z32VT2I033CR31W1317S337L31612I031PJ317W31WU32MX32112I931P031872GC32H631WP323R32AE2M5323U2I9321127432WD2ID318O31A533E62I9318Q31PS318T2JI323U31X9318Z31JV2JX319431RH3197314A316D319B2XC31KS2DV27232ZG313T33ES31KZ25D319N2O62DV26R319R31LH33F133EW33AE324T339431CF3144322M31J22KW26U31AD31LH33FE31KZ25L31JC31CC31AM32IM325C31R8339N2CW31AX314431AZ27531B1311I315Q326J311K31B933DU32IM31BD27131RP2IQ31IS31BM27931IS2SH32ND338O22X26633ET2M633F62IQ32VY33EZ31KF339B31AF31KK31LH26333FK31OU33FM31A433FO31CI339J32P933FZ31CP325M31IJ31FH32JZ2SF31CY327032E727931KN2GG31D72I531DA32K72DV31DE2SK2781L31FH33BI2SH31DO31TM31DR31AF33BT31GB336033BW31TL2V62DG31NB2DE33I12CW31NB319729031GA31VJ33CC315S33CA31TF33CC2M52M531803115336O33CI31FI33CK31OT33CN311Q25A31FH2I032V332PH3188316I2I032252NQ320731HF2NQ33DF33HK22X25431O9311I32H3337B33D7330B31OH33CR322Q31FI238322U315D33DL31GL31PB32WC31OV315D327532AJ3211338031Q0321N31BT31HE33E52GC318N31PY33EA318G2NQ318U27433JV339633JZ31PT279314A32N6274314A2G833E33243314431I232HN2GU32HL318M31OE339P3197316933EN31CE338N33GM24E33F231E8313Y31AF31R0338U22X24331KV31LH33L531QZ31Z433F933FX2MK31AO314A33FB31CF246313Y31AO31AF33LI31KZ2CX325231JM31CW2KW33FS31CF31R833FW311K315I314A31AO315Q315I315I339O31ZK31D231JJ33K931BA33BK24D33G6314422Q31Z932PD320B314431G333GE31S331A531AF33ML31A231A433FA31C32DV23C31ON31AE313V31Y133LQ31CE31AO33FT326N33FQ22131CM31CC33AV31A5325K33MG31KB33H82SB2I931YH33B431LH31SF33HD33J132Z131DC32AM32YX33CL22X25131FH33HQ2SB2CF31PJ31D131WA31AF220320B321631DC32UD2V416316K2GG330V2GM2GF3148330J316A315M335V327W2SF32UA33HW2GU32F033653364279336632042ND311H31ND31H331NG2X628H336D32A6336G2YR3188336J31MP313X32FI32F532YT2SC321P3300336T316J336V3224336X32FV336Z31HG3371322C313P3374318W322I31WY3379322N316X2MK315G32VQ2NQ21G337G31OT2I5337J31H8337M316J31HS337P32MU32GP323833OP3184337V31WU337X31H032GZ318B323K33753242338432H733DX32H032HA31PU32X32ID32HE31BT32HG33QX32HI321A32ZP315E314A313X31BS2I032YZ32ON32YZ33R632V433A032ZZ32JB33QZ32I12IQ32XB31J23169339D31AA31AF33RM31AF22F31JC32JJ31CE339H325831CF3241339L325D32IM274315Q31R43241339R338F31CQ33BK22L339W31BT32Z432J122X32Z7313T1Z31FH33A6311E2O62I032ZI31BT32ZH33L0313T2A033RF32Y533RB21K33AK31AF33SX33AN326K2KW326M31ZJ31JM33S231CM33S42SF33AX31LH33SI32JW33B131D833B332K1313T32VS33NK33JQ327732K831PB327C2KW33BF32GN31DK2Y131D132KI27931DC314Q31KW2SN23321V2U433BR33SF2HC1V33HP2CW31AC32U72SM32U732EJ33U6315M33TD2U422Z33UG327W33UJ322N33OE317733KF32GN22231UD2DD23F31AO33NU2WH33BZ2VJ31P033C233C12VJ31972DV33OU2YM33OW33C933OZ31VJ33VB33CD338531TF32GM310B33P7311Q32F533PW2SC2NQ26I33CQ32MY32UL32GT316I33CV336X33CX316P31MP33D031041K33J7316U33D533PS33D831OH28H33PX317D27824J33DE33Q733JL317S2I9317R317J31HS33DN323E33DP31PY33DS33VH318933DW338831MP33E0318H31BT33E432WX33KO33E831A5318R31MP318U33QV33K933EG31LC33EI33G2319632HM31PV33EO33R533SM22X31JB33RD313T33XM31LH26231IL317J33XR32Y031AF33XU324S33RI31QM33MQ31BT32Q32KW25F33FF31AF33Y531KZ33GB31CB33GU33N031CG31AR325E324133LT33FU22X33FW33S231B431CD324133G131BB2TJ33FJ325P2IQ31L133XV313T33YW31LH33GG31KB33GD33XK25V33GH27533Z531KZ24Q33GJ2ID3393319F2I033DD2CV32I727533ZG32Y333M533GV31CG33GY31Y933N53253316027O2ID33H333GI31KB33H62SH33ND33BJ32PK27924U31LT33HF31NE31DC33HI32Z5311Q26933HN31FJ2TZ31DP31H131AF24N313Y23D33SA29U2DV32UL33UY33QM2VM33V133V42WH33V333V633C533V92YR33VF336H33VD336Y321J33IB318833CG310433VL311I33VN31PV327C23X33VS31PJ33VU31HM33VW31O131MP316O318B2M533W2310B25333W532Z1329M33W8317633WA341E33WD22X21S322U33J333Q3317N317J33WK33DK31WY33WO32MW31WP33DQ31GU33DT2JX33QP33WW33DZ31PS33E2318J2IQ33E633K031Q033K2318433EC2IH33EE31A533XB31RH33XD33XD33EL33XH32YH32WX31KS31M0325T31LH23131SG31GX324I33ZE317V31ON33G931WB33LA324T33S22MK33Y132XB31A92KW33ME2CV33MW279343S33ZL33FL33YD33FO33YF33S133FR31AY31OV33YL31OV326J33YP33YK33G233NA2Q331YM2IQ33ML343I318Y320B33Z3317J234343931AF344M31KZ223343K33XZ33RB33JH33ZH31LH344V343X33YC31AA33GW31RF33ZP31BT33ZR344833H23306344I33ZY32DI340031RI33NH31AF2O433NK340731DB31DD340B311I23K340E31NW33UZ31LP33HS313T21W31ON340M31EC2842L9315D327P31OV31FP2ZZ32EE2HH33BR32U5314C');

local BitXOR = bit and bit.bxor or function(a,b)
    local p,c=1,0
    while a>0 and b>0 do
        local ra,rb=a%2,b%2
        if ra~=rb then c=c+p end
        a,b,p=(a-ra)/2,(b-rb)/2,p*2
    end
    if a<b then a=b end
    while a>0 do
        local ra=a%2
        if ra>0 then c=c+p end
        a,p=(a-ra)/2,p*2
    end
    return c
end

local function gBit(Bit, Start, End)
	if End then
		local Res = (Bit / 2 ^ (Start - 1)) % 2 ^ ((End - 1) - (Start - 1) + 1);
		return Res - Res % 1;
	else
		local Plc = 2 ^ (Start - 1);
        return (Bit % (Plc + Plc) >= Plc) and 1 or 0;
	end;
end;

local Pos = 1;

local function gBits32()
    local W, X, Y, Z = Byte(ByteString, Pos, Pos + 3);

	W = BitXOR(W, 105)
	X = BitXOR(X, 105)
	Y = BitXOR(Y, 105)
	Z = BitXOR(Z, 105)

    Pos	= Pos + 4;
    return (Z*16777216) + (Y*65536) + (X*256) + W;
end;

local function gBits8()
    local F = BitXOR(Byte(ByteString, Pos, Pos), 105);
    Pos = Pos + 1;
    return F;
end;

local function gBits16()
    local W, X = Byte(ByteString, Pos, Pos + 2);

	W = BitXOR(W, 105)
	X = BitXOR(X, 105)

    Pos	= Pos + 2;
    return (X*256) + W;
end;

local function gFloat()
	local Left = gBits32();
	local Right = gBits32();
	local IsNormal = 1;
	local Mantissa = (gBit(Right, 1, 20) * (2 ^ 32))
					+ Left;
	local Exponent = gBit(Right, 21, 31);
	local Sign = ((-1) ^ gBit(Right, 32));
	if (Exponent == 0) then
		if (Mantissa == 0) then
			return Sign * 0; -- +-0
		else
			Exponent = 1;
			IsNormal = 0;
		end;
	elseif (Exponent == 2047) then
        return (Mantissa == 0) and (Sign * (1 / 0)) or (Sign * (0 / 0));
	end;
	return LDExp(Sign, Exponent - 1023) * (IsNormal + (Mantissa / (2 ^ 52)));
end;

local gSizet = gBits32;
local function gString(Len)
    local Str;
    if (not Len) then
        Len = gSizet();
        if (Len == 0) then
            return '';
        end;
    end;

    Str	= Sub(ByteString, Pos, Pos + Len - 1);
    Pos = Pos + Len;

	local FStr = {}
	for Idx = 1, #Str do
		FStr[Idx] = Char(BitXOR(Byte(Sub(Str, Idx, Idx)), 105))
	end

    return Concat(FStr);
end;

local gInt = gBits32;
local function _R(...) return {...}, Select('#', ...) end

local function Deserialize()
    local Instrs = {};
    local Functions = {};
	local Lines = {};
    local Chunk = 
	{
		Instrs,
		Functions,
		nil,
		Lines
	};
	local ConstCount = gBits32()
    local Consts = {}

	for Idx=1, ConstCount do 
		local Type =gBits8();
		local Cons;
	
		if(Type==0) then Cons = (gBits8() ~= 0);
		elseif(Type==2) then Cons = gFloat();
		elseif(Type==1) then Cons = gString();
		end;
		
		Consts[Idx] = Cons;
	end;
for Idx=1,gBits32() do Lines[Idx]=gBits32();end;for Idx=1,gBits32() do Functions[Idx-1]=Deserialize();end;
                            local function createInstruction(instructionType)
                                local instruction = {gBits16(), gBits16(), nil, nil}

                                if instructionType == 0 then 
                                    instruction[3] = gBits16()
                                    instruction[4] = gBits16()
                                elseif instructionType == 1 then 
                                    instruction[3] = gBits32()
                                elseif instructionType == 2 then 
                                    instruction[3] = gBits32() - (2 ^ 16)
                                elseif instructionType == 3 then 
                                    instruction[3] = gBits32() - (2 ^ 16)
                                    instruction[4] = gBits16()
                                else
                                    error("Invalid instruction type: " .. tostring(instructionType))
                                end

                                return instruction
                            end

                            local function applyMask(instruction, mask)
                                if gBit(mask, 1, 1) == 1 then 
                                    instruction[2] = Consts[instruction[2]] 
                                end
                                if gBit(mask, 2, 2) == 1 then 
                                    instruction[3] = Consts[instruction[3]] 
                                end
                                if gBit(mask, 3, 3) == 1 then 
                                    instruction[4] = Consts[instruction[4]] 
                                end
                            end

                            for idx = 1, gBits32() do 
                                local descriptor = gBits8()

                                if gBit(descriptor, 1, 1) == 0 then
                                    local instructionType = gBit(descriptor, 2, 3)
                                    local mask = gBit(descriptor, 4, 6)

                                    local instruction = createInstruction(instructionType)

                                    applyMask(instruction, mask)

                                    Instrs[idx] = instruction
                                end
                            end
                            ;Chunk[3] = gBits8();return Chunk;end;
local PCall = pcall
local function Wrap(Chunk, Upvalues, Env)
	local Instr = Chunk[1];
	local Proto = Chunk[2];
	local Params = Chunk[3];

	return function(...)
		local InstrPoint = 1;
		local Top = -1;

		local Args = {...};
		local PCount = Select('#', ...) - 1;

		local function Loop()
			local Instr  = Instr; 
			local Const  = Const; 
			local Proto  = Proto; 
			local Params = Params;

			local _R = _R
			local Vararg = {};

			local Lupvals	= {};
			local Stk		= {};
	
			for Idx = 0, PCount do
				if (Idx >= Params) then
					Vararg[Idx - Params] = Args[Idx + 1];
				else
					Stk[Idx] = Args[Idx + 1];
				end;
			end;
	
			local Varargsz = PCount - Params + 1

			local Inst;
			local Enum;	

			while true do
				Inst		= Instr[InstrPoint];
				Enum		= Inst[1];if Enum <= 64 then if Enum <= 31 then if Enum <= 15 then if Enum <= 7 then if Enum <= 3 then if Enum <= 1 then if Enum == 0 then 
local A = Inst[2];
local Step = Stk[A + 2];
local Index = Stk[A] + Step;
Stk[A] = Index;
if (Step > 0) then 
	if (Index <= Stk[A+1]) then
		InstrPoint = Inst[3];
		Stk[A+3] = Index;
	end
elseif (Index >= Stk[A+1]) then
	InstrPoint = Inst[3];
	Stk[A+3] = Index;
end
else 
local A = Inst[2]; 
do return Unpack(Stk, A, Top) end;end; elseif Enum > 2 then Stk[Inst[2]]=(Inst[3]~=0);else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum <= 5 then if Enum == 4 then Stk[Inst[2]]=Stk[Inst[3]];else if (Inst[2] < Stk[Inst[4]]) then InstrPoint=Inst[3]; else InstrPoint=InstrPoint+1; end;end; elseif Enum > 6 then 
local A = Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Top))
else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum <= 11 then if Enum <= 9 then if Enum > 8 then Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];else local Step;local Index;local B;local A;A=Inst[2];B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
end; elseif Enum == 10 then Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];else 
local A = Inst[2]
Stk[A] = Stk[A]()
end; elseif Enum <= 13 then if Enum == 12 then 
do return Stk[Inst[2]] end
else local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
do return Stk[A](Unpack(Stk, A + 1, Inst[3])) end;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]; 
do return Unpack(Stk, A, Top) end;InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];do return end;end; elseif Enum == 14 then if(Stk[Inst[2]] < Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];end; elseif Enum <= 23 then if Enum <= 19 then if Enum <= 17 then if Enum == 16 then if Stk[Inst[2]] then InstrPoint=InstrPoint + 1; else InstrPoint = Inst[3]; end;else InstrPoint=Inst[3];end; elseif Enum == 18 then local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];else local A;
A= Inst[2]
Stk[A] = Stk[A](Stk[A + 1]) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Stk[A + 1]) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]();InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];do return end;end; elseif Enum <= 21 then if Enum == 20 then Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];else Stk[Inst[2]][Stk[Inst[3]]]=Stk[Inst[4]];end; elseif Enum == 22 then Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];else Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];end; elseif Enum <= 27 then if Enum <= 25 then if Enum > 24 then do return end;else local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];end; elseif Enum > 26 then 
local A = Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
else Stk[Inst[2]]=Env[Inst[3]];end; elseif Enum <= 29 then if Enum > 28 then local Step;local Index;local A;Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];end; elseif Enum > 30 then Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];else local Step;local Index;local A;Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
end; elseif Enum <= 47 then if Enum <= 39 then if Enum <= 35 then if Enum <= 33 then if Enum == 32 then local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];else local NewProto=Proto[Inst[3]];local NewUvals;local Indexes={};NewUvals=Setmetatable({},{__index=function(_,Key)local Val=Indexes[Key];return Val[1][Val[2]];end,__newindex=function(_,Key,Value)local Val=Indexes[Key] Val[1][Val[2]]=Value;end;});for Idx=1,Inst[4] do InstrPoint=InstrPoint+1;local Mvm=Instr[InstrPoint];if Mvm[1]==73 then Indexes[Idx-1]={Stk,Mvm[3]};else Indexes[Idx-1]={Upvalues,Mvm[3]};end;Lupvals[#Lupvals+1]=Indexes;end;Stk[Inst[2]]=Wrap(NewProto,NewUvals,Env);end; elseif Enum > 34 then Stk[Inst[2]]={};else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum <= 37 then if Enum > 36 then Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];else Stk[Inst[2]]=(Inst[3]~=0);end; elseif Enum == 38 then 
local A = Inst[2];
local Step = Stk[A + 2];
local Index = Stk[A] + Step;
Stk[A] = Index;
if (Step > 0) then 
	if (Index <= Stk[A+1]) then
		InstrPoint = Inst[3];
		Stk[A+3] = Index;
	end
elseif (Index >= Stk[A+1]) then
	InstrPoint = Inst[3];
	Stk[A+3] = Index;
end
else if (Stk[Inst[2]]<Stk[Inst[4]])then InstrPoint=Inst[3]; else InstrPoint=InstrPoint+1; end;end; elseif Enum <= 43 then if Enum <= 41 then if Enum == 40 then if(Stk[Inst[2]] < Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else if(Stk[Inst[2]]~=Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;end; elseif Enum == 42 then local NewProto=Proto[Inst[3]];local NewUvals;local Indexes={};NewUvals=Setmetatable({},{__index=function(_,Key)local Val=Indexes[Key];return Val[1][Val[2]];end,__newindex=function(_,Key,Value)local Val=Indexes[Key] Val[1][Val[2]]=Value;end;});for Idx=1,Inst[4] do InstrPoint=InstrPoint+1;local Mvm=Instr[InstrPoint];if Mvm[1]==73 then Indexes[Idx-1]={Stk,Mvm[3]};else Indexes[Idx-1]={Upvalues,Mvm[3]};end;Lupvals[#Lupvals+1]=Indexes;end;Stk[Inst[2]]=Wrap(NewProto,NewUvals,Env);else local Step;local Index;local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
end; elseif Enum <= 45 then if Enum == 44 then Stk[Inst[2]]=Upvalues[Inst[3]];else Stk[Inst[2]]=Stk[Inst[3]] - Inst[4];end; elseif Enum == 46 then local A=Inst[2];local B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Inst[4]];else Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];end; elseif Enum <= 55 then if Enum <= 51 then if Enum <= 49 then if Enum == 48 then local A=Inst[2];local B=Stk[Inst[3]];Stk[A+1]=B;Stk[A]=B[Inst[4]];else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum == 50 then local Step;local Index;local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else Stk[Inst[2]]();end; elseif Enum <= 53 then if Enum > 52 then 
local A = Inst[2]
local Results, Limit = _R(Stk[A](Stk[A + 1]))
Top = Limit + A - 1
local Edx = 0;
for Idx = A, Top do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end;
else Stk[Inst[2]][Inst[3]] = Stk[Inst[4]];end; elseif Enum > 54 then local Step;local Index;local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else Stk[Inst[2]][Stk[Inst[3]]]=Stk[Inst[4]];end; elseif Enum <= 59 then if Enum <= 57 then if Enum > 56 then 
do return Stk[Inst[2]] end
else Stk[Inst[2]]=Stk[Inst[3]] - Inst[4];end; elseif Enum == 58 then local B=Stk[Inst[4]];if not B then InstrPoint=InstrPoint+1;else Stk[Inst[2]]=B;InstrPoint=Inst[3];end;else Stk[Inst[2]]=Stk[Inst[3]]+Stk[Inst[4]];end; elseif Enum <= 61 then if Enum == 60 then Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];else Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];end; elseif Enum <= 62 then local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3]; elseif Enum == 63 then if(Stk[Inst[2]]==Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else Stk[Inst[2]]=Upvalues[Inst[3]];end; elseif Enum <= 96 then if Enum <= 80 then if Enum <= 72 then if Enum <= 68 then if Enum <= 66 then if Enum == 65 then 
local A = Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Top))
else local Step;local Index;local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
end; elseif Enum == 67 then local Step;local Index;local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else 
local A = Inst[2]
Stk[A] = Stk[A](Stk[A + 1]) 
end; elseif Enum <= 70 then if Enum == 69 then local Step;local Index;local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else 
local A = Inst[2]
Stk[A] = Stk[A](Stk[A + 1]) 
end; elseif Enum > 71 then Top=Inst[2];else local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];end; elseif Enum <= 76 then if Enum <= 74 then if Enum > 73 then Env[Inst[3]] = Stk[Inst[2]];else Stk[Inst[2]]=Stk[Inst[3]];end; elseif Enum > 75 then if Stk[Inst[2]] then InstrPoint=InstrPoint + 1; else InstrPoint = Inst[3]; end;else Stk[Inst[2]] = Inst[3];end; elseif Enum <= 78 then if Enum == 77 then local Step;local Index;local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else 
local A = Inst[2];
do return Stk[A](Unpack(Stk, A + 1, Inst[3])) end;end; elseif Enum > 79 then Stk[Inst[2]]={};else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum <= 88 then if Enum <= 84 then if Enum <= 82 then if Enum > 81 then 
local A = Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
else Stk[Inst[2]]=Env[Inst[3]];end; elseif Enum > 83 then Stk[Inst[2]][Inst[3]] = Stk[Inst[4]];else if (Stk[Inst[2]]<Stk[Inst[4]])then InstrPoint=Inst[3]; else InstrPoint=InstrPoint+1; end;end; elseif Enum <= 86 then if Enum > 85 then local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];else local B=Inst[3];local K=Stk[B] for Idx=B+1,Inst[4] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;end; elseif Enum == 87 then local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum <= 92 then if Enum <= 90 then if Enum == 89 then if(Stk[Inst[2]]~=Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else 
local A = Inst[2]; 
do return Unpack(Stk, A, Top) end;end; elseif Enum > 91 then InstrPoint=Inst[3];else local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];end; elseif Enum <= 94 then if Enum == 93 then Stk[Inst[2]] = Inst[3];else 
local A = Inst[2];
local Index = Stk[A]
local Step = Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
end; elseif Enum == 95 then local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];else Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];end; elseif Enum <= 112 then if Enum <= 104 then if Enum <= 100 then if Enum <= 98 then if Enum == 97 then local B=Inst[3];local K=Stk[B] for Idx=B+1,Inst[4] do K=K..Stk[Idx];end;Stk[Inst[2]]=K;else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum == 99 then local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];else if(Inst[2] < Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;end; elseif Enum <= 102 then if Enum == 101 then Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];else 
local A = Inst[2];
do return Stk[A](Unpack(Stk, A + 1, Inst[3])) end;end; elseif Enum > 103 then local Step;local Index;local A;Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]]-Stk[Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];InstrPoint=Inst[3];end; elseif Enum <= 108 then if Enum <= 106 then if Enum == 105 then if(Inst[2] < Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else if (Inst[2] < Stk[Inst[4]]) then InstrPoint=Inst[3]; else InstrPoint=InstrPoint+1; end;end; elseif Enum == 107 then Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];else Stk[Inst[2]]=#Stk[Inst[3]];end; elseif Enum <= 110 then if Enum == 109 then local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];else local B=Stk[Inst[4]];if not B then InstrPoint=InstrPoint+1;else Stk[Inst[2]]=B;InstrPoint=Inst[3];end;end; elseif Enum > 111 then Stk[Inst[2]]();else 
local A = Inst[2]
Stk[A](Stk[A + 1])
end; elseif Enum <= 120 then if Enum <= 116 then if Enum <= 114 then if Enum == 113 then local Step;local Index;local A;Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Stk[A + 1]) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Env[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]={};InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2];
Index= Stk[A]
Step= Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
else Stk[Inst[2]]=Wrap(Proto[Inst[3]],nil,Env);end; elseif Enum == 115 then Stk[Inst[2]]=#Stk[Inst[3]];else Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];end; elseif Enum <= 118 then if Enum == 117 then 
local A = Inst[2]
Stk[A] = Stk[A]()
else 
local A = Inst[2]
local Results, Limit = _R(Stk[A](Stk[A + 1]))
Top = Limit + A - 1
local Edx = 0;
for Idx = A, Top do 
	Edx = Edx + 1;
	Stk[Idx] = Results[Edx];
end;
end; elseif Enum == 119 then local A;Stk[Inst[2]] = Stk[Inst[3]] % Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];
A= Inst[2]
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3])) 
InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]]=Stk[Inst[3]];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];InstrPoint = InstrPoint + 1;Inst = Instr[InstrPoint];Stk[Inst[2]] = Inst[3];else do return end;end; elseif Enum <= 124 then if Enum <= 122 then if Enum == 121 then Stk[Inst[2]]=Stk[Inst[3]]+Stk[Inst[4]];else 
local A = Inst[2];
local Index = Stk[A]
local Step = Stk[A + 2];
if (Step > 0) then 
	if (Index > Stk[A+1]) then
		InstrPoint = Inst[3];
	else
		Stk[A+3] = Index;
	end
elseif (Index < Stk[A+1]) then
	InstrPoint = Inst[3];
else
	Stk[A+3] = Index;
end
end; elseif Enum > 123 then Stk[Inst[2]] = Stk[Inst[3]] * Inst[4];else Env[Inst[3]] = Stk[Inst[2]];end; elseif Enum <= 126 then if Enum > 125 then Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];else Stk[Inst[2]]=Wrap(Proto[Inst[3]],nil,Env);end; elseif Enum <= 127 then 
local A = Inst[2]
Stk[A](Stk[A + 1])
 elseif Enum == 128 then if(Stk[Inst[2]]==Stk[Inst[4]])then InstrPoint=InstrPoint+1;else InstrPoint=Inst[3];end;else Top=Inst[2];end;
				InstrPoint	= InstrPoint + 1;
			end;
		end;

		A, B = _R(PCall(Loop))
		if not A[1] then
			local line = Chunk[7][InstrPoint] or '?'
			error('ERROR IN ScriptGuard SCRIPT [LINE ' .. line .. ']:' .. A[2])
		else
			return Unpack(A, 2, B)
		end;
	end;
end;	
return Wrap(Deserialize(), {}, GetFEnv())();

